{"name":"Shen","tagline":"Erlang JavaScript Parse Transform","body":"Erlang JavaScript Parse Transform\r\n=================================\r\n\r\nTill now all existed attempts to bring Erlang to the browser is nothing than playing with mind.\r\nNo emulation of terrible Erlang bytecode is needed. In fact Erlang bytecode is relict\r\nthat is even translated by BEAM into more modern internal bytecode. So every project\r\nthat attempt to translate on BEAM byte-code level not only slow but in fact is a useless.\r\n\r\nLibraries\r\n---------\r\n\r\nWe support following stack by Erlang JavaScript compiler:\r\n\r\n* matches.js -- Erlang-like matching syntax\r\n* tailrec.js -- optimize tail calls\r\n* beacon.js -- FRP event streaming\r\n\r\nThe only real pratical fast solution is to translate Erlang AST into JavaScript\r\nusing JavaScript helpers like matches.js and tailrec.js.\r\n\r\nUsage\r\n-----\r\n\r\n* Compilation to JavaScript, node.js, Browser, Client-Side FRP\r\n* Macros, String Templates, Embedding Mode, Server-Side, N2O\r\n\r\nCompilation to Pure JavaScript\r\n------------------------------\r\n\r\nIn case of Client-Logic, Off-line clients, Client-side FRP Event System\r\nuse can export you functions in module with -js attribute.\r\nAll function will be stored to the same filename with js extension.\r\n\r\nfac.erl:\r\n\r\n    -module(fac).\r\n    -compile({parse_transform, shen}).\r\n    -compile(export_all).\r\n\r\n    -js([start/0,fac/1]).\r\n\r\n    start() ->\r\n        N = fac(5),\r\n        console:log(\"factorial ~p\", [J, N]).\r\n\r\n    fac(0) -> 1;\r\n    fac(N) -> N * fac(N-1).\r\n\r\nCompile with Erlang:\r\n\r\n    $ erlc shen.erl\r\n    $ erlc -pa . fac.erl\r\n\r\nAnd you will get fac.js:\r\n\r\n    var pattern = require(\"matches\").pattern;\r\n    var start = pattern({\r\n        '': function() {\r\n            j = 5;\r\n            n = fac(j);\r\n            return console.log('factorial ~p',[j,[n,[]]]);\r\n    }});\r\n    var fac = pattern({\r\n        '0': function(x1) {\r\n            return 1;\r\n        },\r\n        'n': function(n) {\r\n            return n * fac(n - 1);\r\n    }});\r\n    start();\r\n\r\nNow you can check:\r\n\r\n    $ node fac.js\r\n    factorial ~p [ 5, [ 120, [] ] ]\r\n\r\nJavaScript Macros\r\n-----------------\r\n\r\nLet say we want to generate JavaScript in our Erlang code which is very useful\r\nfor Server-Logic Event System, so you can write programs in Erlang and expand\r\nthem into JavaScript using -jsmacro attribute. Specified functions will be\r\nexpanded to JavaScript during compilation.\r\n\r\n    -module(fac).\r\n    -compile({parse_transform, shen}).\r\n    -compile(export_all).\r\n\r\n    -jsmacro([macro/3]).\r\n\r\n    macro(A,B,C) ->\r\n        ws:send('Bert':encodebuf(\r\n            [{source,'Bert':binary(A)},\r\n             {x,C},\r\n             {pickle,'Bert':binary(B)},\r\n             {linked,C}])).\r\n\r\n    main() ->\r\n        A = \"1\",\r\n        B = \"2\",\r\n        Script = macro(A,B,\"3\"),\r\n        io:format(\"JS Macro: ~s\",[Script]).\r\n\r\nLets try it:\r\n\r\n    7> fac:main().\r\n    JS Macro: ws.send(Bert.encodebuf({source:Bert.binary(1),x:3,pickle:Bert.binary(2),linked:3}));\r\n    ok\r\n\r\nCredits\r\n-------\r\n\r\n    * Maxim Sokhatsky\r\n    * Andrew Zadorozhny\r\n\r\nOM A HUM\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}